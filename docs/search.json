[
  {
    "objectID": "Project1.html",
    "href": "Project1.html",
    "title": "ST558 - Project 1",
    "section": "",
    "text": "The general goal of this project is to build functions to query the Public Use Microdata Sample (PUMS) Census API and to do some simple analysis and plotting of this data. Our goal is to build functions which allow a user to modify arguments in the function to determine what data are returned from the query. The project is broken down into steps, starting with data processing, which addresses the query process, and then moves on to summarizing and testing steps."
  },
  {
    "objectID": "Project1.html#introduction",
    "href": "Project1.html#introduction",
    "title": "ST558 - Project 1",
    "section": "",
    "text": "The general goal of this project is to build functions to query the Public Use Microdata Sample (PUMS) Census API and to do some simple analysis and plotting of this data. Our goal is to build functions which allow a user to modify arguments in the function to determine what data are returned from the query. The project is broken down into steps, starting with data processing, which addresses the query process, and then moves on to summarizing and testing steps."
  },
  {
    "objectID": "Project1.html#data-processing",
    "href": "Project1.html#data-processing",
    "title": "ST558 - Project 1",
    "section": "Data Processing",
    "text": "Data Processing\nHere we build the query process. We start by loading relevant packages.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr)\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\n\nNext, we start our data processing step by getting the process to work with a particular URL. We will use the URL provided on page 3 of the pdf which describes the requirements for Project 1.\nThe first step creates a string for the URL.\n\nURL_id &lt;- 'https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24'\n\nThe next step uses the GET() function from the httr package to get the data from the API, and uses the str function to view the structure of the object obatined.\n\nid_info &lt;- GET(URL_id)\nstr(id_info, max.level = 1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-09-19 23:15:13\"\n $ times      : Named num [1:6] 0 0.00991 0.03981 0.11955 0.38519 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nWe see the object obatined is a list of length 10 and that the actual data is stored in an object in the list called content. We can see the type of content is raw, so we need to parse the data. To start this we can combine the rawToChar function with the fromJSON function from the jsonlite package.\n\nparsed &lt;- fromJSON(rawToChar(id_info$content))\nclass(parsed)\n\n[1] \"matrix\" \"array\" \n\nhead(parsed)\n\n     [,1]  [,2]    [,3]  [,4]  \n[1,] \"SEX\" \"PWGTP\" \"MAR\" \"SCHL\"\n[2,] \"2\"   \"6\"     \"5\"   \"24\"  \n[3,] \"2\"   \"23\"    \"2\"   \"24\"  \n[4,] \"1\"   \"23\"    \"3\"   \"24\"  \n[5,] \"1\"   \"80\"    \"5\"   \"24\"  \n[6,] \"1\"   \"16\"    \"1\"   \"24\"  \n\n\nFrom the printout of the parsed object, we see that it is a character matrix with the column names assuming the first row of the matrix. In the next step we fix this by removing the first row and assigning it as the names of the object.\n\nparsed_data &lt;- parsed[2:nrow(parsed),]\ncolnames(parsed_data) &lt;- parsed[1,]\nhead(parsed_data)\n\n     SEX PWGTP MAR SCHL\n[1,] \"2\" \"6\"   \"5\" \"24\"\n[2,] \"2\" \"23\"  \"2\" \"24\"\n[3,] \"1\" \"23\"  \"3\" \"24\"\n[4,] \"1\" \"80\"  \"5\" \"24\"\n[5,] \"1\" \"16\"  \"1\" \"24\"\n[6,] \"1\" \"107\" \"3\" \"24\"\n\n\nNow that the matrix is in the desired form, we use the as_tibble() function from the dplyr package to convert it into a tibble.\n\nparsed_final &lt;- as_tibble(parsed_data)\nparsed_final\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n\nNow we have our desired result for a particular example URL.\nIn the next step, we write a helper function which takes an arbitrary URL (appropriate for API query) as an argument and returns a nice tibble. To do so, we will simply make slight modifications to the preceding code which performs this task for a particular URL.\n\nhelper &lt;- function(URL){\n  id_info &lt;- GET(URL)\n  parsed &lt;- fromJSON(rawToChar(id_info$content))\n  parsed_data &lt;- parsed[2:nrow(parsed),]\n  colnames(parsed_data) &lt;- parsed[1,]\n  parsed_final &lt;- as_tibble(parsed_data)\n  parsed_final\n}\n\nWe test the helper function on 2023 public use microdata and see it functions as desired.\n\nhelper('https://api.census.gov/data/2023/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24')\n\n# A tibble: 45,584 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 1     23    2     24   \n 2 1     36    2     24   \n 3 1     9     5     24   \n 4 2     22    2     24   \n 5 1     14    5     24   \n 6 1     13    5     24   \n 7 1     35    5     24   \n 8 2     15    3     24   \n 9 2     77    5     24   \n10 1     7     5     24   \n# ℹ 45,574 more rows\n\n\nWe see from the output that the function behaves as desired.\nOur next task is to write a function to query the API that allows the user to change the items in the fashion laid out in the pdf for Project 1 description. We will name the function query. Comments are included in the code for the function to describe what is being done at each step. The arguments to the function will be year, a character vector called num_var which will be a vector of the desired numeric variables listed as strings, and a character vector called cat_var which will be a vector of the desired categorical variables listed as strings.\n\nquery &lt;- function(year = 2022, num_var = c('AGEP'), cat_var = c('SEX')){\n  \n  #we build up the URL one input variable at a time\n  #at each step we use ifelse() to check that the input variables belong to the allowable set of variables\n  \n  URL_1 &lt;- ifelse(\n    year &lt;= 2022 & year &gt;= 2010 & as.integer(year) - year == 0, \n    paste0('https://api.census.gov/data/', year, '/acs/acs1/pums?get=PWGTP'), \n    stop('You must provide a year from 2010 to 2022')\n    )\n  \n  URL_2 &lt;- ifelse(\n    FALSE %in% (num_var %in% c('AGEP', 'GASP', 'GRPIP', 'JWAP', 'JWDP', 'JWMNP')),\n    stop('You must choose numeric variables from AGEP, GASP, GRPIP, JWAP, JWDP, or JWMNP'),\n    paste(num_var, collapse = ',')\n    )\n  \n  URL_3 &lt;- ifelse(\n    FALSE %in% (cat_var %in% c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL', 'SEX')),\n    stop('You must choose categorical variables from FER, HHL, HISPEED, JWTRNS, SCH, SCHL, or SEX'),\n    paste(cat_var, collapse = ',')\n    )\n    \n  #subsetting to be done on API call\n  \n  #We paste together all the indivicual components of the URL to create a final URL \n  URL_final &lt;- paste(URL_1, URL_2, URL_3, sep = ',')\n  \n\n  #The previously created helper function is used to return the desired tibble\n  helper(URL_final)\n}\n\nHere we test the function with the goal of returning from year 2011 the GASP, JWMNP, and FER columns.\n\nquery(2011, c('GASP', 'JWMNP'), c('FER'))\n\n# A tibble: 3,112,017 × 4\n   PWGTP GASP  JWMNP FER  \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 13    2     0     0    \n 2 22    2     0     2    \n 3 56    40    0     0    \n 4 55    40    0     0    \n 5 88    130   0     0    \n 6 72    130   0     0    \n 7 40    210   0     0    \n 8 37    10    60    0    \n 9 115   90    15    0    \n10 109   90    30    0    \n# ℹ 3,112,007 more rows"
  },
  {
    "objectID": "Project1.html#writing-a-generic-function-for-summarizing",
    "href": "Project1.html#writing-a-generic-function-for-summarizing",
    "title": "ST558 - Project 1",
    "section": "Writing a Generic Function for Summarizing",
    "text": "Writing a Generic Function for Summarizing"
  },
  {
    "objectID": "Project1.html#interesting-investigation",
    "href": "Project1.html#interesting-investigation",
    "title": "ST558 - Project 1",
    "section": "Interesting Investigation",
    "text": "Interesting Investigation"
  }
]