---
title: "ST558 - Project 1"
authors: Brian Rabe and Michelle Silveira
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

## Introduction

The primary objective of this project is to develop functions to query the Public Use Microdata Sample (PUMS) Census API and perform fundamental analysis and plotting of the resulting data. Our goal is to build functions that allow a user to modify arguments in the function to determine what data is returned from the query. The project is broken down into steps, starting with data processing, which addresses the query process, and then moves on to summarizing and testing steps.

## Data Processing

Here we build the query process. We start by loading relevant packages.

```{r}
library(tidyverse)
library(httr)
library(jsonlite)
```

Next, we initiate our data processing step by setting up the process to work with a specific URL. We will use the URL provided on page 3 of the PDF, which describes the requirements for Project 1.

The first step creates a string for the URL.

```{r}
URL_id <- 'https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24'
```

The next step uses the `GET()` function from the `httr` package to get the data from the API, and uses the `str` function to view the structure of the object obtained.

```{r}
id_info <- GET(URL_id)
str(id_info, max.level = 1)
```

We see the object obtained is a list of length 10 and that the actual data is stored in an object in the list called `content`. We can see that the type of content is raw, so we need to parse the data. To start this we can combine the `rawToChar` function with the `fromJSON` function from the `jsonlite` package.

```{r}
parsed <- fromJSON(rawToChar(id_info$content))
class(parsed)
head(parsed)
```

From the printout of the `parsed` object, we see that it is a character matrix, with the column names assumed in the first row of the matrix. In the next step, we fix this by removing the first row and assigning it as the names of the object.

```{r}
parsed_data <- parsed[2:nrow(parsed),]
colnames(parsed_data) <- parsed[1,]
head(parsed_data)
```

Now that the matrix is in the desired form, we use the `as_tibble()` function from the `dplyr` package to convert it into a tibble.

```{r}
parsed_final <- as_tibble(parsed_data)
parsed_final
```

Now we have our desired result for a particular example URL.

In the next step, we write a helper function which takes an arbitrary URL (appropriate for API query) as an argument and returns a nice tibble. To do so, we will simply make slight modifications to the preceding code. The object obtained is a list of length 10, which takes an arbitrary URL (appropriate for a task that performs this task for a particular URL.

```{r}
helper <- function(URL){
  id_info <- GET(URL)
  parsed <- fromJSON(rawToChar(id_info$content))
  parsed_data <- parsed[2:nrow(parsed),]
  colnames(parsed_data) <- parsed[1,]
  parsed_final <- as_tibble(parsed_data)
  parsed_final
}
```

We test the helper function on the 2023 public use microdata and see that it works as desired.

```{r}
test <- helper('https://api.census.gov/data/2023/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24')
```

We see from the output that the function behaves as desired.

Our next task is to write a function that queries the API, allowing the user to modify the items in the fashion laid out in the PDF for Project 1's description. We will name the function `query`. Comments are included in the code for the function to describe what is being done at each step. The arguments to the function will be `year,` which will be taken as a double or an integer, a character vector called `num_var` which will be a vector of the desired numeric variables listed as strings, a character vector called `cat_var` which will be a vector of the desired categorical variables listed as strings, and the geography level which will be taken as a string.

```{r}
query <- function(year = 2022, num_var = c('AGEP'), cat_var = c('SEX'), geography = 'all'){
  
  #we build up the URL one input variable at a time
  #at each step we use ifelse() to check that the input variables belong to the allowable set of variables
  
  URL_1 <- ifelse(
    year <= 2022 & year >= 2010 & as.integer(year) - year == 0, 
    paste0('https://api.census.gov/data/', year, '/acs/acs1/pums?get=PWGTP'), 
    stop('You must provide a year from 2010 to 2022')
    )
  
  URL_2 <- ifelse(
    FALSE %in% (num_var %in% c('AGEP', 'GASP', 'GRPIP', 'JWAP', 'JWDP', 'JWMNP')),
    stop('You must choose numeric variables from AGEP, GASP, GRPIP, JWAP, JWDP, or JWMNP'),
    paste(num_var, collapse = ',')
    )
  
  URL_3 <- ifelse(
    FALSE %in% (cat_var %in% c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL', 'SEX')),
    stop('You must choose categorical variables from FER, HHL, HISPEED, JWTRNS, SCH, SCHL, or SEX'),
    paste(cat_var, collapse = ',')
    )
  
  ifelse(
    FALSE %in% (geography %in% c('all', 'region', 'division', 'state')),
    stop('You must choose a geography level from all, region, division, or state'),
    URL_4 <- paste0('&for=', geography)
  )
    
  #subsetting to be done on API call
  
  
  #We paste together all the individual components of the URL to create a final URL 
  ifelse(
    geography == 'all',
    URL_final <- paste(URL_1, URL_2, URL_3, sep = ','),
    URL_final <- paste0(paste(URL_1, URL_2, URL_3, sep = ','), URL_4)
  )
  

  #The previously created helper function is used to return the desired tibble in character form, which is stored in object data_character
  helper(URL_final)

}
```

Here, we test the function intended to return the GASP, JWMNP, and FER columns for the year 2011, with the specified state geography.

```{r}
query(2011, c('JWAP', 'JWMNP', 'AGEP'), c('FER'), geography = 'state')
```

## Writing a Generic Function for Summarizing

Creating a summary function 
```{r}
summary.census <- function(object, num = NULL, cat = NULL, ...) {
  stopifnot(inherits(object, 'census'))
  if (!'PWGTP' %in% names(object)) stop('PWGTP column is required')
  if (!is.numeric(object$PWGTP)) suppressWarnings(object$PWGTP <- as.numeric(object$PWGTP))

  # Default selection: detect numeric via type; pass num/cat explicitly when needed
  is_num <- vapply(object, is.numeric, logical(1))
  default_num <- setdiff(names(object)[is_num], 'PWGTP')
  default_cat <- names(object)[!is_num]
  if (is.null(num)) num <- default_num else num <- intersect(num, names(object))
  if (is.null(cat)) cat <- default_cat else cat <- intersect(cat, names(object))

  w_mean <- function(x, w) {
    x <- suppressWarnings(as.numeric(x)); w <- suppressWarnings(as.numeric(w))
    sum(x * w, na.rm = TRUE) / sum(w, na.rm = TRUE)
  }
  w_sd <- function(x, w) {
    x <- suppressWarnings(as.numeric(x)); w <- suppressWarnings(as.numeric(w))
    mu <- w_mean(x, w)
    sqrt(sum((x^2) * w, na.rm = TRUE) / sum(w, na.rm = TRUE) - mu^2)
  }

  numeric_summary <- NULL
  if (length(num) > 0) {
    numeric_summary <- purrr::map_dfr(num, function(v) {
      x <- suppressWarnings(as.numeric(object[[v]]))
      w <- object$PWGTP
      tibble::tibble(
        var = v,
        n_nonmissing = sum(!is.na(x)),
        weight_sum   = sum(w, na.rm = TRUE),
        w_mean       = w_mean(x, w),
        w_sd         = w_sd(x, w)
      )
    })
  }

  categorical_summary <- NULL
  if (length(cat) > 0) {
    categorical_summary <- purrr::map_dfr(cat, function(v) {
      fac <- factor(object[[v]])
      lv  <- levels(fac)
      unwt <- as.integer(table(fac)[lv])
      wt <- tapply(object$PWGTP, fac, sum)
      wt <- as.numeric(wt[lv]); wt[is.na(wt)] <- 0
      tibble::tibble(var = v, level = lv, unweighted_n = unwt, weighted_n = wt)
    })
  }

  out <- list(numeric_summary = numeric_summary, categorical_summary = categorical_summary)
  class(out) <- 'summary.census'
  out
}

```

Including the plot function
```{r}
plot.census <- function(x, num_var, cat_var, ...) {
  stopifnot(inherits(x, 'census'))
  if (missing(num_var) || missing(cat_var)) stop('Provide one numeric and one categorical var')
  if (!(num_var %in% names(x)) || !(cat_var %in% names(x))) stop('Variables not found')

  ggplot2::ggplot(
    x,
    ggplot2::aes(x = .data[[cat_var]], y = as.numeric(.data[[num_var]]), weight = PWGTP)
  ) +
    ggplot2::geom_boxplot()
}

```


Here, we test the function using synthetic data
```{r}
set.seed(1)
dat <- tibble(
  PWGTP = c(10, 20, 30, 40),
  AGEP  = c(25, 30, 45, 50),
  JWMNP = c(15, NA, 35, 45),
  SEX   = factor(c('1','2','1','2')),
  SCHL  = c('24','24','16','16')
)
class(dat) <- c('census', class(dat))

s <- summary(dat)
s
stopifnot(all(c('var','w_mean','w_sd') %in% names(s$numeric_summary)))
stopifnot(all(c('var','level','weighted_n') %in% names(s$categorical_summary)))

plot(dat, num_var = 'AGEP', cat_var = 'SEX')

```

Here, we test the function using query built in the previous steps
```{r}
# options(timeout = 120)

df <- query(2022, num_var = c('AGEP'), cat_var = c('SEX'))
# Ensure numeric type
for (v in c('PWGTP','AGEP')) if (v %in% names(df)) df[[v]] <- suppressWarnings(as.numeric(df[[v]]))
class(df) <- c('census', class(df))

summary(df)
plot(df, num_var = 'AGEP', cat_var = 'SEX')


```

## Interesting Investigation
